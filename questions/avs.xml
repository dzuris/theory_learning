<data>
    <element>
        <question>Predikcia skokov</question>
        <answer>- statická (podľa testu ≠0, &gt;0, ≥0, smeru skoku kompilátorom - predict bit) - založená na inštrukcii
- dynamická (za behu) - založená na histórií vykonaní

- lokálna - história udržiavaná iba pre danú inštrukciu (adaptívna)
- globálna - história udržiavaná cez sekvencie skokov (korelačná)</answer>
    </element>
    <element>
        <question>Trace cache</question>
        <answer>- načíta inštrukcie, ale ukladá ich už sekvenčne za sebou
Fungovanie:
1. Sledovanie inštrukcií - Keď procesor vykonáva program, môže sledovať alebo "traceovať" postupnosť vykonávaných inštrukcií. Tento sled môže zahrňovať viacero inštrukcií v určitom poradí, ktoré sú vzájomne závislé a často vykonávané.
2. Ukladanie do trace cache - Sledované stopy alebo sledy inštrukcií sa ukladajú do trace cache, kde sú prednačítané a uchovávané. To znamená, že tieto stopy sú uložené v pamäti blízko k jádru procesora, čo znižuje čas prístupu k nim.
3. Rýchle vykonávanie programov - Keď je potrebné vykonávať inštrukcie, procesor môže využiť inštrukcie uložené v trace cache, čo zrýchľuje vykonávanie programov, pretože nemusí čakať na načítanie inštrukcií z hlavnej pamäte.

Trace cache je špeciálne užitočná pre programy, ktoré majú veľký počet skokov a podmienených inštrukcií, pretože umožňuje procesoru prednačítať správne inštrukcie na základe sledovaných stop a minimalizovať oneskorenie spojené so zmätkom a čakaním na načítanie inštrukcií. Tým sa zvyšuje výkon procesora a umožňuje efektívnejšie vykonávanie programov.</answer>
    </element>
    <element>
        <question>Riadiace konflikty</question>
        <answer>
- nepodmienený skok
    - absolútny
    - do podprogramu
- podmienený skok
    - skáče podľa registrov (podľa predchádzajúcej operácie)</answer>
    </element>
    <element>
        <question>Adaptívne prediktory</question>
        <answer>- rozhodujeme sa na základe posledných k bitov
- vie sa prispôsobiť rôznym postupnostiam
- problémy: veľkosť prediktorov rastie exponencionálne s počtom bitov histórie</answer>
    </element>
    <element>
        <question>Korelačné prediktory</question>
        <answer>- špecifický typ skokových prediktorov, ktoré sa snažia predikovať výsledok skokových inštrukcií na základe korelácie medzi rôznymi skokovými inštrukciami v programe. Tieto prediktory využívajú historické vzory správania sa skokov v programe na zlepšenie presnosti predikcie. Existujú dva hlavné typy korelačných prediktorov: globálny korelačný prediktor a lokálny korelačný prediktor.
        - globálny korelačný prediktor - sleduje vzory správania sa skokov vo všetkých častiach programu.
        - lokálny korelačný prediktor - sleduje vzory správania sa skokov len v okolí konkrétnej skokovej inštrukcie.</answer>
    </element>
    <element>
        <question>Skalárny procesor</question>
        <answer>- vykonáva inštrukcie sekvenčne, t.j. jednu za druhou. To znamená že vykonáva iba 1 inštrukciu za 1 taktný cyklus.
- inštrukcie sú vykonávané v poradí, v akom sú v programovom kóde
- tieto procesory majú jednoduchú architektúru a sú vhodné pre jednoduché úlohy, kde inštrukcie nie sú silne závisle</answer>
    </element>
    <element>
        <question>Superskalárne procesory</question>
        <answer>- je schopný vykonávať viacero inštrukcii za 1 taktný cyklus. To znamená, že môže paralelne vykonávať viacero inštrukcii, ak sú k dispozícií a spĺňajú podmienky.
- inštrukcie môžu byť vykonávané v nezávislom poradí, čo zvyšuje výkonnosť procesora.
- majú komplexnejšiu architektúru a sú schopné rýchlejšie spracovávať zložité a náročne programy.</answer>
    </element>
    <element>
        <question>Organizácia jednotky L/S podporujúca RPW (Store buffer)</question>
        <answer>AVS_03/16</answer>
    </element>
    <element>
        <question>Out-of-order Load/Store jednotka (Load buffer)</question>
        <answer>AVS_03/18</answer>
    </element>
    <element>
        <question>Bypassing a forwarding</question>
        <answer>- Load z adresy ,,Z'' predbehne Store s inou adresou ,,X'', ktoré ešte nezačalo (bypassing)
- Load načíta dáta z ešte nedokončenej inštrukcie Store s rovnakou adresou ,,X'' (Load from Store forwarding, predávanie)</answer>
    </element>
    <element>
        <question>Read can pass Write</question>
        <answer>- hlavný zdroj lepšej výkonnosti, načítanie totiž býva na začiatku tela smyčiek so závislými inštrukciami.
- nový Load môže predbehnúť aktuálny Store, iterácie smyčiek sa môžu čiastočne prekrývať</answer>
    </element>
    <element>
        <question>AVX2 a AVX512</question>
        <answer>- sú to instrukčné sady ktoré sa v moderných CPUs používajú an vykonávanie SIMD(Single Instruction Multiple Data) operácií.
- AVX2 je 256-bitová vektorová inštrukčná sada, ktorá podporuje niekoľko interpretácií 256-bitových registrov, ako napríklad 8 floatov, 4 double alebo 32 bajtov. K existujúcim operáciiám s pohyblivou desatinnou čiarkou podporovaným systémom AVX1 pridáva 256-bitové operácie s celými číslami.

- AVX512 je súbor 512-bitových vektorových inštrukcií, ktorý rozširuje možnosti AVX2. Používa nové kódovanie prefixu EVEX (enhanced vector extension) a podporuje mnoho rôznych inštrukcií. Najväčší rozdiel medzi AVX2 a AVX512 je v tom, že AVX512 dokáže spracovať dvakrát viac operácií na inštrukciu.</answer>
    </element>
    <element>
        <question>Amdahlov a Gustafsonov zákon</question>
        <answer>P1</answer>
    </element>
    <element>
        <question>Superskalárny procesor - Backend</question>
        <answer>- Odpovedá stupňom EX, MA, WB:
- vykonáva a ukladá výsledky niekoľkých inštrukcií súbežne.
- niektoré stupne sú rozdelené na pod stupne.
- počet (skupin) funkčných jednotiek je minimálne m, ale počet prepojovacích ciest rastie ako m^2.

Dnes m najviac 6 až 9, ale dôležité je IPC: koľko inštrukcií priemerne končí za 1 takt a to je o dosť menej než m.</answer>
    </element>
    <element>
        <question>Rozdelenie superskalárnych procesorov</question>
        <answer>Delenie podľa spôsobu akým inštrukcie opúšťajú front-end:
- Podľa poradia v programe, po vyriešení konfliktov (in-order, INO), jednoduchý HW.
- Mimo poradia (out-of-order, OOO). Nepravé konflikty vyriešené premenovaním v HW, RAW riešený čakaním rozpracovaných inštrukcií. Zápis výsledkov v pôvodnom poradí zaistený zoraďovaciou pamäťou (ROB).

Príklady:
- INO: prvé superskalárne procesory (Pentium, DEC Alpha 21164), ale aj novšie (IBM Power6, Intel Atom, ARM...)
- OOO: Intel P6, Pentium4, Intel Core,... až Rocket Lake či Zen.</answer>
    </element>
    <element>
        <question>Rysy superskalárnych procesorov</question>
        <answer>- Paralélne reťazené linky (INO aj OOO) - časový aj priestorový paralelizmus
- Premenovanie registrov v HW (OOO) - odstránenie konfliktov WAR a WAW
- Dynamické plánovanie inštrukcií out-of-order (OOO)
    - Po dekódovaní čakajú inštrukcie na svoje operandy, ktoré sa tvoria. Akonáhle sú operandy pripravené, spustí sa operácia.
    - Inštrukcie, vrátane prístupu do pamäte, sú spracovávané v inom poradí oproti oproti poradí v programe
- Zoraďovacia pamäť (OOO)
    - stupeň WB pomocou nej zaisťuje ukládanie výsledkov v poradí určenom zdrojovým kódom
- Špekulatívne spracovanie inštrukcii (OOO)
    - špekulácia, že skok dopadne podľa predikcie alebo že dopredu načítané dáta sa už nezmenia.</answer>
    </element>
    <element>
        <question>4 veci ktoré sú podmienkou úspešnej vektorizácie cyklu</question>
        <answer>1. Musí byť spočítateľný počet iterácií (const param)
2. Nesmie obsahovať volanie funkcií (okrem funkcií ktoré podporujú vektorizáciu)
3. Žiadne skoky
4. Jeden vstup a výstup (žiaden break)</answer>
    </element>
    <element>
        <question>RAT</question>
        <answer>RAT (Register Alias Table) je hardvérová štruktúra, ktorá sleduje premenovanie architektonických registrov na fyzické registre. Používa sa na riešenie konfliktov názvov registrov, ktoré vznikajú pri súčasnom vykonávaní viacerých inštrukcií.</answer>
    </element>
    <element>
        <question>ROB</question>
        <answer>ROB (Reorder Buffer) - zoraďovacia pamäť - je hardvérová štruktúra, ktorá sleduje inštrukcie, ktoré boli vydané, ale ešte neboli vyradené. Používa sa na zabezpečenie toho, aby boli inštrukcie vyradené v programovom poradí, aj keď sa dokončia mimo poradia.
- je kruhová vyrovnávacia pamäť rozpracovaných inštrukcií obsahujúca:
    - informácie o stave inštrukcie
    - predbežné/špekulatívne výsledky
- Inštrukcie sú vložené do ROB pri vydaní do RS
- Všetky inštrukcie sú tu udržované v fronte FIFO v programovom poradí.
- Prepúšťanie inštrukcie iba z čela ROB, po prepustení všetkých predchádzajúcich inštrukcií.
- Zápis do arch registrov/pamätí pri opúšťaní ROB.
- ROB môže byť použitý aj pre premenovanie</answer>
    </element>
    <element>
        <question>BTB</question>
        <answer>BTB (Branch Target Buffer) je hardvérová štruktúra, ktorá ukladá do vyrovnávacej pamäte cieľovú adresu nedávno vykonaných inštrukcií vetvenia. Používa sa na predvídanie cieľovej adresy budúcich inštrukcií vetvenia a na zníženie výkonnostnej penalizácie spojenej s nesprávnymi predpovediami vetvenia.</answer>
    </element>
    <element>
        <question>PHT</question>
        <answer>Pattern History Table - je hardvérová štruktúra používaná pri dynamickej predikcii vetiev. Pozostáva z priamo mapovaných položiek a uchováva históriu niekoľkých posledných výsledkov vetvenia. PHT sa používa na predpovedanie smeru nasledujúcej inštrukcie vetvenia a na určenie cieľovej adresy podmienenej inštrukcie vetvenia.</answer>
    </element>
    <element>
        <question>Názvy dvoch základných implementácií hardvérovej podpory pre sekvenčne prednačítanie</question>
        <answer>- Prednačítanie pri výpadku - pri výpadku v bloku i sa načíta blok i a prednačíta i+1.
- Prednačítanie s príznakom - pri výpadku v bloku i sa načíta blok i (s príznakom 0) a prednačíta sa blok i+1 (s príznakom 1)
    - pri zásahu v bloku i+1:
        - s príznakom 1 (prvý zásah): zmeň príznak na 0 a prednačítaj blok i+2 (s príznakom 1)
        - s príznakom 0 (druhý a ďalší zásah): žiadna akcia
        
Lepšia implementácia je prednačítanie s rozostupom.</answer>
    </element>
    <element>
        <question>Výhody ROB</question>
        <answer>1. Vykonávanie mimo poradia: ROB umožňuje vykonávať inštrukcie mimo poradia, čo môže zlepšiť výkon tým, že procesor môže vykonávať nezávislé inštrukcie súčasne.
2. Presné výnimky: ROB zabezpečuje presné spracovanie výnimiek, čo znamená, že stav procesora sa vráti späť do bodu výnimky a po výnimke sa nevykonávajú žiadne inštrukcie.
3. Špekulatívne vykonávanie: ROB umožňuje špekulatívne vykonávanie inštrukcií, čo znamená, že procesor môže vykonávať inštrukcie skôr, ako je isté, že budú potrebné. To môže zlepšiť výkon tým, že sa zníži počet zdržaní v pipeline.</answer>
    </element>
    <!-- <element>
        <question></question>
        <answer>Answer num 2</answer>
    </element>
    <element>
        <question></question>
        <answer>Answer num 2</answer>
    </element>
    <element>
        <question></question>
        <answer>Answer num 2</answer>
    </element> -->
</data>
